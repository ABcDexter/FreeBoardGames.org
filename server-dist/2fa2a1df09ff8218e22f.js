exports.ids = [16];
exports.modules = {

/***/ "./src/games/seabattle/ai.ts":
/*!***********************************!*\
  !*** ./src/games/seabattle/ai.ts ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./src/games/seabattle/game.ts\");\n/* harmony import */ var shuffle_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shuffle-array */ \"shuffle-array\");\n/* harmony import */ var shuffle_array__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(shuffle_array__WEBPACK_IMPORTED_MODULE_1__);\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\n\n\n\nclass SeabattleBot {\n  play(state, playerID) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (state.ctx.phase === 'setup') {\n        const shipPositions = Object(_game__WEBPACK_IMPORTED_MODULE_0__[\"generateRandomShips\"])(1);\n        return this.makeSetShipsMove(shipPositions, playerID);\n      } else {\n        const cell = this.generateMove(playerID, state);\n        return this.makeSalvoMove(cell, playerID);\n      }\n    });\n  }\n\n  makeSetShipsMove(ships, playerID) {\n    return {\n      action: {\n        type: 'MAKE_MOVE',\n        payload: {\n          type: 'setShips',\n          args: [ships],\n          playerID\n        }\n      }\n    };\n  }\n\n  makeSalvoMove(cell, playerID) {\n    return {\n      action: {\n        type: 'MAKE_MOVE',\n        payload: {\n          type: 'salvo',\n          args: [cell.x, cell.y],\n          playerID\n        }\n      }\n    };\n  }\n\n  generateMove(playerID, state) {\n    const salvos = state.G.salvos.filter(salvo => salvo.player === Number(playerID) && salvo.hit === true && typeof salvo.hitShip !== 'undefined');\n\n    for (const salvo of salvos) {\n      // if we have already fired salvos, see if we've hit any ships that remain unsunk\n      if (!this.isShipSunk(state, salvo.hitShip)) {\n        const otherHitSalvos = this.getOtherSalvosHitShip(state, salvo.hitShip);\n\n        if (otherHitSalvos.length >= 2) {\n          // we have hit this ship at least twice, so we can make an intelligent move\n          return this.getNextShipFoundMove(state, otherHitSalvos);\n        } // no other salvos for the same ship were hit, so hit a random neighbor\n\n\n        return this.getRandomNeighbor(state, salvo);\n      }\n    } // generate a random move\n\n\n    return this.generateRandomMove(state);\n  }\n\n  getNextShipFoundMove(state, hitSalvos) {\n    const xMap = hitSalvos.map(salvo => salvo.cell.x);\n    const yMap = hitSalvos.map(salvo => salvo.cell.y);\n    const minPos = {\n      x: Math.min(...xMap),\n      y: Math.min(...yMap)\n    };\n    const maxPos = {\n      x: Math.max(...xMap),\n      y: Math.max(...yMap)\n    };\n    const direction = maxPos.x === minPos.x ? {\n      x: 0,\n      y: 1\n    } : {\n      x: 1,\n      y: 0\n    };\n    return this.anyValidMove(state, [{\n      x: minPos.x - direction.x,\n      y: minPos.y - direction.y\n    }, {\n      x: maxPos.x + direction.x,\n      y: maxPos.y + direction.y\n    }]);\n  }\n\n  isInBounds(x) {\n    return x >= 0 && x <= 9;\n  }\n\n  isValidMove(state, cell) {\n    return this.isInBounds(cell.x) && this.isInBounds(cell.y) && this.isUniqueMove(state, cell);\n  }\n\n  anyValidMove(state, moves) {\n    shuffle_array__WEBPACK_IMPORTED_MODULE_1___default()(moves); // ONLY source of randomness\n\n    for (const move of moves) {\n      if (this.isValidMove(state, move)) {\n        return move;\n      }\n    }\n\n    return null;\n  }\n\n  getRandomNeighbor(state, salvo) {\n    return this.anyValidMove(state, [{\n      x: salvo.cell.x - 1,\n      y: salvo.cell.y\n    }, {\n      x: salvo.cell.x,\n      y: salvo.cell.y - 1\n    }, {\n      x: salvo.cell.x + 1,\n      y: salvo.cell.y\n    }, {\n      x: salvo.cell.x,\n      y: salvo.cell.y + 1\n    }]);\n  }\n\n  getOtherSalvosHitShip(state, id) {\n    return state.G.salvos.filter(salvo => salvo.hitShip === id);\n  }\n\n  isShipSunk(state, id) {\n    return state.G.ships.filter(ship => ship.id === id)[0].sunk;\n  }\n\n  generateRandomMove(state) {\n    const allPossibleMoves = [];\n\n    for (let x = 0; x <= 9; x++) {\n      for (let y = 0; y <= 9; y++) {\n        allPossibleMoves.push({\n          x,\n          y\n        });\n      }\n    }\n\n    return this.anyValidMove(state, allPossibleMoves);\n  }\n\n  isUniqueMove(state, cell) {\n    const moves = state.G.salvos.filter(salvo => salvo.player === 1 && salvo.cell.x === cell.x && salvo.cell.y === cell.y);\n    return moves.length === 0;\n  }\n\n}\n\nconst config = {\n  bgioAI: () => {\n    return {\n      bot: SeabattleBot\n    };\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (config);\n\n//# sourceURL=webpack:///./src/games/seabattle/ai.ts?");

/***/ }),

/***/ "./src/games/seabattle/game.ts":
/*!*************************************!*\
  !*** ./src/games/seabattle/game.ts ***!
  \*************************************/
/*! exports provided: playerView, SeabattleGame, generateRandomShips, validateShips, getCellVector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"playerView\", function() { return playerView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SeabattleGame\", function() { return SeabattleGame; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generateRandomShips\", function() { return generateRandomShips; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateShips\", function() { return validateShips; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCellVector\", function() { return getCellVector; });\n/* harmony import */ var _freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @freeboardgame.org/boardgame.io/core */ \"@freeboardgame.org/boardgame.io/core\");\n/* harmony import */ var _freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shortid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shortid */ \"shortid\");\n/* harmony import */ var shortid__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(shortid__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst VALID_SHIPS_SIZES = [5, 4, 3, 2];\nconst VALID_SHIPS_COUNT = {\n  5: 1,\n  4: 1,\n  3: 2,\n  2: 1\n};\nconst playerView = (G, ctx, playerID) => {\n  const player = parseInt(playerID, 10);\n  const ships = G.ships.filter(ship => ship.player === player || ship.sunk);\n  return Object.assign({}, G, {\n    ships\n  });\n};\nconst SeabattleGame = Object(_freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__[\"Game\"])({\n  name: 'seabattle',\n  setup: () => ({\n    ships: [],\n    salvos: []\n  }),\n  moves: {\n    setShips(G, ctx, ships) {\n      const player = parseInt(ctx.playerID, 10);\n      const validation = validateShips(ships, player);\n\n      if (!validation.valid) {\n        throw new Error(validation.error);\n      }\n\n      return Object.assign({}, G, {\n        ships: [...G.ships, ...ships]\n      });\n    },\n\n    salvo(G, ctx, x, y) {\n      const player = parseInt(ctx.playerID, 10);\n      const shipIndex = findShipWithCell(G.ships, {\n        x,\n        y\n      }, player); // Do not allow the same cells to be shot twice\n\n      const uniqueMove = G.salvos.filter(salvo => salvo.player === player && salvo.cell.x === x && salvo.cell.y === y).length === 0;\n\n      if (!uniqueMove) {\n        return Object.assign({}, G);\n      }\n\n      if (shipIndex === -1) {\n        // Miss\n        return Object.assign({}, G, {\n          salvos: [...G.salvos, {\n            player,\n            hit: false,\n            cell: {\n              x,\n              y\n            }\n          }]\n        });\n      }\n\n      const ship = G.ships[shipIndex]; // Hit\n\n      const newShips = [...G.ships];\n\n      if (countShipHits(G.salvos, ship.id) + 1 === ship.cells.length) {\n        newShips[shipIndex] = Object.assign({}, newShips[shipIndex], {\n          sunk: true\n        });\n      }\n\n      return Object.assign({}, G, {\n        ships: newShips,\n        salvos: [...G.salvos, {\n          player,\n          hit: true,\n          cell: {\n            x,\n            y\n          },\n          hitShip: ship.id\n        }]\n      });\n    }\n\n  },\n  flow: {\n    startingPhase: 'setup',\n    phases: {\n      setup: {\n        allowedMoves: ['setShips'],\n        turnOrder: _freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__[\"TurnOrder\"].ANY_ONCE,\n        next: 'play'\n      },\n      play: {\n        endGameIf: G => {\n          if (checkAllShipsSunk(G.ships, 0)) {\n            return {\n              winner: '1'\n            };\n          }\n\n          if (checkAllShipsSunk(G.ships, 1)) {\n            return {\n              winner: '0'\n            };\n          }\n        },\n        allowedMoves: ['salvo'],\n        movesPerTurn: 1\n      }\n    }\n  },\n  playerView\n}); // Helper function for generating random ships positioning.\n\nfunction generateRandomShips(player) {\n  let result;\n  let shipID;\n\n  do {\n    result = [];\n\n    for (const shipSize of VALID_SHIPS_SIZES) {\n      const count = VALID_SHIPS_COUNT[shipSize];\n\n      for (let i = 0; i < count; i++) {\n        shipID = shortid__WEBPACK_IMPORTED_MODULE_1___default.a.generate();\n        result.push(randomlyGetShip(player, shipSize, shipID));\n      }\n    }\n  } while (!validateShips(result, player).valid);\n\n  return result;\n} // Wheather a setup is valid or not.\n\nfunction validateShips(ships, player) {\n  const validations = [validateShipsCount(ships), validateShipsContinuity(ships), validateShipsNotOutOfBounds(ships), validateShipsNotOverlapping(ships), validateShipsHaveUniqueIDs(ships)];\n\n  if (player !== undefined) {\n    validations.push(validateShipsOwnership(player, ships));\n  }\n\n  for (const validation of validations) {\n    if (!validation.valid) {\n      return validation;\n    }\n  }\n\n  return {\n    valid: true\n  };\n} // PRIVATE FUNCTIONS\n\nfunction checkAllShipsSunk(ships, player) {\n  for (const ship of ships) {\n    if (ship.player === player && !ship.sunk) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction randomlyGetShip(player, shipSize, id) {\n  const cell = {\n    x: getRandomInt(10),\n    y: getRandomInt(10)\n  };\n  const direction = getRandomInt(2) === 1 ? 'H' : 'V';\n  const ship = {\n    player,\n    cells: [],\n    sunk: false,\n    id\n  };\n\n  for (let i = 0; i < shipSize; i++) {\n    if (direction === 'H') {\n      // Constant y\n      ship.cells.push(Object.assign({}, cell, {\n        x: cell.x + i\n      }));\n    } else {\n      // Constant x\n      ship.cells.push(Object.assign({}, cell, {\n        y: cell.y + i\n      }));\n    }\n  }\n\n  return ship;\n}\n\nfunction getRandomInt(max) {\n  return Math.floor(Math.random() * Math.floor(max));\n}\n\nfunction findShipWithCell(ships, cell, player) {\n  return ships.findIndex(ship => ship.cells.findIndex(c => c.x === cell.x && c.y === cell.y) !== -1 && ship.player !== player);\n}\n\nfunction countShipHits(salvos, shipId) {\n  return salvos.filter(s => s.hitShip === shipId).length;\n}\n\nfunction validateShipsCount(ships) {\n  const shipsLength = ships.map(ship => ship.cells.length);\n  const count = Object.assign({}, VALID_SHIPS_COUNT);\n\n  for (const length of shipsLength) {\n    if (!(length in count)) {\n      return {\n        valid: false,\n        error: `Invalid ship length: ${length}`\n      };\n    }\n\n    count[length]--;\n  }\n\n  for (const length of Object.values(count)) {\n    if (length !== 0) {\n      return {\n        valid: false,\n        error: 'Invalid ships sizes.'\n      };\n    }\n  }\n\n  return {\n    valid: true\n  };\n}\n\nfunction validateShipsOwnership(player, ships) {\n  const owners = ships.map(ship => ship.player);\n\n  for (const owner of owners) {\n    if (owner !== player) {\n      return {\n        valid: false,\n        error: `Invalid player owner: ${owner} should be: ${player}`\n      };\n    }\n  }\n\n  return {\n    valid: true\n  };\n}\n\nfunction validateShipsContinuity(ships) {\n  for (const ship of ships) {\n    if (ship.cells.length < 2) {\n      continue;\n    }\n\n    let lastICell = ship.cells[0];\n    const vector = getCellVector(ship.cells[1], ship.cells[0]);\n\n    if (!(Math.abs(vector.x) === 1 && Math.abs(vector.y) === 0 || Math.abs(vector.x) === 0 && Math.abs(vector.y) === 1)) {\n      return {\n        valid: false,\n        error: `IShip is not spaced right!`\n      };\n    }\n\n    for (let i = 1; i < ship.cells.length; i++) {\n      const cell = ship.cells[i];\n      const newVector = getCellVector(cell, lastICell);\n\n      if (newVector.x !== vector.x || newVector.y !== vector.y) {\n        return {\n          valid: false,\n          error: `IShip is not continuous!`\n        };\n      }\n\n      lastICell = cell;\n    }\n  }\n\n  return {\n    valid: true\n  };\n}\n\nfunction getCellVector(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\n\nfunction validateShipsHaveUniqueIDs(ships) {\n  const usedIDs = {};\n\n  for (const ship of ships) {\n    if (usedIDs[ship.id]) {\n      return {\n        valid: false,\n        error: `IShip IDs are not unique!`\n      };\n    }\n\n    usedIDs[ship.id] = true;\n  }\n\n  return {\n    valid: true\n  };\n}\n\nfunction validateShipsNotOutOfBounds(ships) {\n  for (const ship of ships) {\n    for (const cell of ship.cells) {\n      if (cell.x < 0 || cell.x > 9 || cell.y < 0 || cell.y > 9) {\n        return {\n          valid: false,\n          error: `IShip out of bounds!`\n        };\n      }\n    }\n  }\n\n  return {\n    valid: true\n  };\n}\n\nfunction validateShipsNotOverlapping(ships) {\n  const cellsUsed = {};\n\n  for (const ship of ships) {\n    for (const cell of ship.cells) {\n      if (!(cell.x in cellsUsed)) {\n        cellsUsed[cell.x] = {};\n      }\n\n      if (cellsUsed[cell.x][cell.y]) {\n        return {\n          valid: false,\n          error: `Overlapping ships!`\n        };\n      }\n\n      cellsUsed[cell.x][cell.y] = true;\n    }\n  }\n\n  return {\n    valid: true\n  };\n}\n\n//# sourceURL=webpack:///./src/games/seabattle/game.ts?");

/***/ })

};;