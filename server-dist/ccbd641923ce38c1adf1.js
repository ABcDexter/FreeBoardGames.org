exports.ids = [14];
exports.modules = {

/***/ "./src/games/checkers/ai.ts":
/*!**********************************!*\
  !*** ./src/games/checkers/ai.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./src/games/checkers/game.ts\");\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\n\n\nclass CheckersRandomBot {\n  play(state, playerID) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const moves = state.G.jumping !== null ? Object(_game__WEBPACK_IMPORTED_MODULE_0__[\"getValidMoves\"])(state.G, playerID, state.G.jumping) : Object(_game__WEBPACK_IMPORTED_MODULE_0__[\"getValidMoves\"])(state.G, playerID);\n      const move = moves[Math.floor(Math.random() * moves.length)];\n      return this.makeMove(playerID, move);\n    });\n  }\n\n  makeMove(playerID, move) {\n    return {\n      action: {\n        type: 'MAKE_MOVE',\n        payload: {\n          type: 'move',\n          args: [move.from, move.to],\n          playerID\n        }\n      }\n    };\n  }\n\n}\n\nconst config = {\n  bgioAI: () => {\n    return {\n      bot: CheckersRandomBot\n    };\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (config);\n\n//# sourceURL=webpack:///./src/games/checkers/ai.ts?");

/***/ }),

/***/ "./src/games/checkers/game.ts":
/*!************************************!*\
  !*** ./src/games/checkers/game.ts ***!
  \************************************/
/*! exports provided: INITIAL_BOARD, sumCoords, multiplyCoord, inBounds, toCoord, toIndex, areCoordsEqual, checkPosition, getValidMoves, move, CheckersGame */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"INITIAL_BOARD\", function() { return INITIAL_BOARD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sumCoords\", function() { return sumCoords; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyCoord\", function() { return multiplyCoord; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inBounds\", function() { return inBounds; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toCoord\", function() { return toCoord; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toIndex\", function() { return toIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"areCoordsEqual\", function() { return areCoordsEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkPosition\", function() { return checkPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getValidMoves\", function() { return getValidMoves; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"move\", function() { return move; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CheckersGame\", function() { return CheckersGame; });\n/* harmony import */ var _freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @freeboardgame.org/boardgame.io/core */ \"@freeboardgame.org/boardgame.io/core\");\n/* harmony import */ var _freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst piece = (id, player) => ({\n  id,\n  playerID: player.toString(),\n  isKing: false\n});\n\nconst INITIAL_BOARD = [null, piece(0, 1), null, piece(1, 1), null, piece(2, 1), null, piece(3, 1), piece(4, 1), null, piece(5, 1), null, piece(6, 1), null, piece(7, 1), null, null, piece(8, 1), null, piece(9, 1), null, piece(10, 1), null, piece(11, 1), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, piece(12, 0), null, piece(13, 0), null, piece(14, 0), null, piece(15, 0), null, null, piece(16, 0), null, piece(17, 0), null, piece(18, 0), null, piece(19, 0), piece(20, 0), null, piece(21, 0), null, piece(22, 0), null, piece(23, 0), null];\nconst MAN_DIRS = [[{\n  x: -1,\n  y: -1\n}, {\n  x: 1,\n  y: -1\n}], [{\n  x: -1,\n  y: 1\n}, {\n  x: 1,\n  y: 1\n}]];\nconst KING_DIRS = [{\n  x: -1,\n  y: 1\n}, {\n  x: 1,\n  y: 1\n}, {\n  x: -1,\n  y: -1\n}, {\n  x: 1,\n  y: -1\n}];\nfunction sumCoords(a, b) {\n  return {\n    x: a.x + b.x,\n    y: a.y + b.y\n  };\n}\nfunction multiplyCoord(coord, multiplier) {\n  return {\n    x: coord.x * multiplier,\n    y: coord.y * multiplier\n  };\n}\nfunction inBounds(coord) {\n  return coord.x >= 0 && coord.x < 8 && coord.y >= 0 && coord.y < 8;\n}\nfunction toCoord(position) {\n  const x = position % 8;\n  const y = Math.floor(position / 8);\n  return {\n    x,\n    y\n  };\n}\nfunction toIndex(coord) {\n  return coord.x + coord.y * 8;\n}\nfunction areCoordsEqual(a, b) {\n  return a.x === b.x && a.y === b.y;\n}\nfunction checkPosition(G, playerID, piece, coord) {\n  const dirs = piece.isKing ? KING_DIRS : MAN_DIRS[playerID];\n  let moves = [];\n  let jumped = false;\n\n  for (const dir of dirs) {\n    // Look into all valid directions\n    let opponentBefore = null;\n\n    for (let i = 1; piece.isKing ? true : i < 3; i++) {\n      const final = sumCoords(coord, multiplyCoord(dir, i)); // Break if move is out of bounds\n\n      if (!inBounds(final)) {\n        break;\n      }\n\n      const moveTo = G.board[toIndex(final)]; // Break if we encounter our piece\n\n      if (moveTo !== null && moveTo.playerID === playerID) {\n        break;\n      }\n\n      if (moveTo !== null && moveTo.playerID !== playerID) {\n        // If we already encountered opponent the directions is blocked\n        if (opponentBefore) {\n          break;\n        }\n\n        opponentBefore = final;\n      }\n\n      if (moveTo === null) {\n        moves.push({\n          from: coord,\n          to: final,\n          jumped: opponentBefore\n        });\n\n        if (opponentBefore) {\n          jumped = true;\n          break;\n        } // If there is nothing and the piece isn't king there is no need to continue\n\n\n        if (!piece.isKing) {\n          break;\n        }\n      }\n    }\n  }\n\n  return {\n    moves,\n    jumped\n  };\n}\nfunction getValidMoves(G, playerID, jumping) {\n  let movesTotal = [];\n  let jumpedTotal = false;\n\n  if (typeof jumping === 'undefined') {\n    G.board.forEach((piece, index) => {\n      if (piece !== null && piece.playerID === playerID) {\n        const coord = toCoord(index);\n        const {\n          moves,\n          jumped\n        } = checkPosition(G, playerID, piece, coord);\n        movesTotal.push(...moves);\n        jumpedTotal = jumpedTotal || jumped;\n      }\n    });\n  } else {\n    const {\n      moves,\n      jumped\n    } = checkPosition(G, playerID, jumping.data, jumping.coord);\n    movesTotal = moves;\n    jumpedTotal = jumped;\n  }\n\n  if (jumpedTotal) {\n    return movesTotal.filter(move => move.jumped);\n  } else {\n    return movesTotal;\n  }\n}\nfunction move(G, ctx, from, to) {\n  const indexFrom = toIndex(from);\n  const indexTo = toIndex(to);\n  const piece = G.board[indexFrom];\n  const crownhead = ctx.playerID === '0' ? 0 : 7;\n\n  if (piece === null || piece.playerID !== ctx.playerID || G.board[indexTo] !== null) {\n    return _freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__[\"INVALID_MOVE\"];\n  }\n\n  const moves = G.jumping === null ? getValidMoves(G, ctx.playerID) : getValidMoves(G, ctx.playerID, G.jumping);\n  const move = moves.find(move => areCoordsEqual(move.from, from) && areCoordsEqual(move.to, to));\n\n  if (typeof move === 'undefined') {\n    return _freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__[\"INVALID_MOVE\"];\n  }\n\n  const jumped = move.jumped !== null ? toIndex(move.jumped) : -1;\n  const isKing = piece.isKing || to.y === crownhead;\n  const newG = Object.assign({}, G, {\n    board: G.board.map((square, i) => {\n      switch (i) {\n        case indexFrom:\n          return null;\n\n        case indexTo:\n          return Object.assign({}, piece, {\n            isKing\n          });\n\n        case jumped:\n          return null;\n\n        default:\n          return square;\n      }\n    }),\n    jumping: null\n  });\n\n  if (move.jumped === null) {\n    return newG;\n  }\n\n  const jumping = {\n    data: Object.assign({}, piece, {\n      isKing\n    }),\n    coord: to\n  };\n  const postMoves = getValidMoves(newG, ctx.playerID, jumping);\n\n  if (postMoves.length > 0 && postMoves[0].jumped !== null) {\n    return Object.assign({}, newG, {\n      jumping\n    });\n  }\n\n  return newG;\n}\nconst CheckersGame = Object(_freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__[\"Game\"])({\n  name: 'checkers',\n  setup: () => ({\n    board: INITIAL_BOARD,\n    jumping: null\n  }),\n  moves: {\n    move\n  },\n  flow: {\n    movesPerTurn: 1,\n    turnOrder: {\n      first: () => 0,\n      next: (G, ctx) => G.jumping === null ? (ctx.playOrderPos + 1) % ctx.numPlayers : ctx.playOrderPos\n    },\n    endGameIf: (G, ctx) => {\n      if (getValidMoves(G, ctx.currentPlayer === '0' ? '1' : '0').length === 0) {\n        return {\n          winner: ctx.currentPlayer\n        };\n      }\n    }\n  }\n});\n\n//# sourceURL=webpack:///./src/games/checkers/game.ts?");

/***/ })

};;