exports.ids = [15];
exports.modules = {

/***/ "./src/games/reversi/ai.ts":
/*!*********************************!*\
  !*** ./src/games/reversi/ai.ts ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./src/games/reversi/game.ts\");\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\n\n\nclass ReversiRandomBot {\n  play(state, playerID) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const moves = Array.from(Object(_game__WEBPACK_IMPORTED_MODULE_0__[\"getValidMoves\"])(state.G, playerID));\n      const move = moves[Math.floor(Math.random() * moves.length)];\n      const x = move % 8;\n      const y = Math.floor(move / 8);\n      return this.makeMove(playerID, x, y);\n    });\n  }\n\n  makeMove(playerID, x, y) {\n    return {\n      action: {\n        type: 'MAKE_MOVE',\n        payload: {\n          type: 'placePiece',\n          args: [x, y],\n          playerID\n        }\n      }\n    };\n  }\n\n}\n\nconst config = {\n  bgioAI: () => {\n    return {\n      bot: ReversiRandomBot\n    };\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (config);\n\n//# sourceURL=webpack:///./src/games/reversi/ai.ts?");

/***/ }),

/***/ "./src/games/reversi/game.ts":
/*!***********************************!*\
  !*** ./src/games/reversi/game.ts ***!
  \***********************************/
/*! exports provided: getValidMoves, placePiece, getScoreBoard, ReversiGame */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getValidMoves\", function() { return getValidMoves; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"placePiece\", function() { return placePiece; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScoreBoard\", function() { return getScoreBoard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReversiGame\", function() { return ReversiGame; });\n/* harmony import */ var _freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @freeboardgame.org/boardgame.io/core */ \"@freeboardgame.org/boardgame.io/core\");\n/* harmony import */ var _freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction toPosition(x, y) {\n  return y * 8 + x;\n}\n\nfunction inBounds(x, y) {\n  return x >= 0 && x < 8 && y >= 0 && y < 8;\n}\n\nfunction getValidMoves(G, playerID) {\n  let validMoves = new Set();\n  G.points.map((player, position) => ({\n    player,\n    position\n  })).filter(point => point.player === playerID).forEach(point => {\n    for (let i = -1; i <= 1; i++) {\n      for (let j = -1; j <= 1; j++) {\n        if (i === 0 && j === 0) {\n          continue;\n        }\n\n        const x = point.position % 8;\n        const y = Math.floor(point.position / 8);\n        let currX = x + i;\n        let currY = y + j;\n        let k = 1;\n        let end = null;\n\n        while (inBounds(currX, currY) && G.points[toPosition(currX, currY)] !== playerID) {\n          const position = toPosition(currX, currY);\n\n          if (G.points[position] === null) {\n            end = position;\n            break;\n          }\n\n          k++;\n          currX = x + i * k;\n          currY = y + j * k;\n        }\n\n        if (end !== null && k > 1) {\n          validMoves.add(end);\n        }\n      }\n    }\n  });\n\n  if (validMoves.size > 0) {\n    return validMoves;\n  }\n\n  G.points.map((player, position) => ({\n    player,\n    position\n  })).filter(point => point.player === null).forEach(point => {\n    for (let i = -1; i <= 1; i++) {\n      for (let j = -1; j <= 1; j++) {\n        if (i === 0 && j === 0) {\n          continue;\n        }\n\n        const x = point.position % 8;\n        const y = Math.floor(point.position / 8);\n\n        if (inBounds(x + i, y + j) && G.points[toPosition(x + i, y + j)] !== null) {\n          validMoves.add(point.position);\n        }\n      }\n    }\n  });\n  return validMoves;\n}\nfunction placePiece(G, ctx, x, y) {\n  if (G.points[toPosition(x, y)] !== null) {\n    return _freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__[\"INVALID_MOVE\"];\n  }\n\n  let changed = [toPosition(x, y)]; // Changed positions\n\n  for (let i = -1; i <= 1; i++) {\n    for (let j = -1; j <= 1; j++) {\n      if (i === 0 && j === 0) {\n        continue;\n      }\n\n      let valid = false;\n      let update = [];\n      let currX = x + i;\n      let currY = y + j;\n\n      for (let k = 2; inBounds(currX, currY) && G.points[toPosition(currX, currY)] !== null; k++) {\n        if (G.points[toPosition(currX, currY)] === ctx.currentPlayer) {\n          valid = true;\n          break;\n        }\n\n        update.push(toPosition(currX, currY));\n        currX = x + i * k;\n        currY = y + j * k;\n      }\n\n      if (valid) {\n        changed.push(...update);\n      }\n    }\n  }\n\n  if (changed.length === 1) {\n    if (getValidMoves(G, ctx.playerID).has(toPosition(x, y))) {\n      return Object.assign({}, G, {\n        points: Object.values(Object.assign({}, G.points, {\n          [toPosition(x, y)]: ctx.playerID\n        }))\n      });\n    }\n\n    return _freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__[\"INVALID_MOVE\"];\n  } else {\n    changed.sort((a, b) => b - a);\n    return Object.assign({}, G, {\n      points: G.points.map((point, i) => {\n        if (changed.length > 0 && i === changed[changed.length - 1]) {\n          changed.pop();\n          return ctx.playerID;\n        } else {\n          return point;\n        }\n      })\n    });\n  }\n}\nfunction getScoreBoard(G, ctx) {\n  let scoreBoard = new Array(ctx.numPlayers).fill(0);\n  G.points.filter(point => point !== null && parseInt(point) < ctx.numPlayers).forEach(point => scoreBoard[point]++);\n  return scoreBoard.map((score, i) => ({\n    playerID: i.toString(),\n    score\n  })).sort((a, b) => b.score - a.score);\n}\nconst GameConfig = {\n  name: 'reversi',\n  flow: {\n    movesPerTurn: 1,\n    endGameIf: (G, ctx) => {\n      if (!G.points.some(point => point === null)) {\n        return {\n          scoreboard: getScoreBoard(G, ctx)\n        };\n      }\n    }\n  },\n  moves: {\n    placePiece\n  },\n  setup: ctx => {\n    let points = Array(64).fill(null);\n\n    if (ctx.numPlayers === 2) {\n      points[toPosition(4, 4)] = '1';\n      points[toPosition(4, 3)] = '2';\n    } else {\n      points[toPosition(4, 3)] = '1';\n      points[toPosition(4, 4)] = '2';\n    }\n\n    points[toPosition(3, 3)] = '0';\n    points[toPosition(3, 4)] = '3';\n    return {\n      points\n    };\n  }\n};\nconst ReversiGame = Object(_freeboardgame_org_boardgame_io_core__WEBPACK_IMPORTED_MODULE_0__[\"Game\"])(GameConfig);\n\n//# sourceURL=webpack:///./src/games/reversi/game.ts?");

/***/ })

};;